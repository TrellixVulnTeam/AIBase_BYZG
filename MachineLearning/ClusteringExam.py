# -*- coding: utf-8 -*-
"""TrialClusteringExam.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lHtw0xgKQOcfOyxafjHIaF5OeKDvtRy3

# Trial Clustering Exam
Find the clusters in the included dataset.

The solution must be produced as a Python Notebook. The notebook must include appropriate comments and must produce:

* the boxplots of the attributes and a comment on remarkable situations, if any (2pt)
* a pairplot of the data (see Seaborn pairplot) and a comment on remarkable situations, if any (2pt)
* a clustering schema using a method of your choice exploring a range of parameter values (5pt)
* the plot of the global inertia (SSD) and silhouette index for the parameter values you examine  (4pt)
* the optimal parameters of your choice (4pt)
* a pairplot of the data using as hue the cluster assignment with the optimal parameter (3pt)
* a plot of the silhouette index for the data points, grouped according to the clusters (4pt)
* A sorted list of the discovered clusters for decreasing sizes (7pt)
"""

# Commented out IPython magic to ensure Python compatibility.
from IPython.display import Image
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score, silhouette_samples

# %matplotlib inline

rnd_state = 42 # This variable will be used in all the procedure calls allowing a random_state parameter
               # in this way the running can be perfectly reproduced
               # just change this value for a different experiment
from plot_clusters import plot_clusters
from plot_silhouette import plot_silhouette

# load data
X = np.loadtxt("lab_exercise.csv", delimiter=',')
df = pd.read_csv("lab_exercise.csv", names=["x", "y", "z", "k"])
df.head()

# First point: BOXPLOT - NOSENSE
sns.boxplot(x=df.loc[:, 'x'], y=df.loc[:, 'y'])

# Second point: PAIRPLOT
sns.pairplot(df)

# Third Point: CLUSTERTING
distortions = []
silhouettes = []
for par in range(2, 10):
  est = KMeans(n_clusters=par)
  cl = est.fit_predict(df)
  distortions.append(est.inertia_)
  silhouettes.append(silhouette_score(df, cl))

# Plot Inertia
plt.plot(distortions)
plt.title("Inertia")
plt.grid()
plt.show()

fig, ax1 = plt.subplots()

color = 'tab:red'
ax1.set_xlabel('Number of clusters')
ax1.set_ylabel('Inertia', color=color)
ax1.plot(range(2, 10), distortions, color=color)
ax1.tick_params(axis='y', labelcolor=color)

ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis

color = 'tab:blue'
ax2.set_ylabel('Silhouette scores', color=color)  # we already handled the x-label with ax1
ax2.plot(range(2, 10), silhouettes, color=color)
ax2.tick_params(axis='y', labelcolor=color)
ax2.set_ylim(0,1) # the axis for silhouette is [0,1]

fig.tight_layout()  # otherwise the right y-label is slightly clipped
plt.show()

# Plot Silhouette
silh = silhouette_samples(X, cl, metric='euclidean')
plot_silhouette(silh, cl)

plot_clusters(X, cl, dim=(2, 1), points=est.cluster_centers_)

# Choice Best Param: 4 cluster
est = KMeans(n_clusters=4)
cl = est.fit_predict(df)


plot_clusters(X, cl, dim=(2, 1), points=est.cluster_centers_)

# Plotting for best param
plot_silhouette(silhouette_samples(df, cl), cl)

sns.pairplot(df)

print(cl)
# list of cluster sorted by dimension
num0 = len(cl[cl == 0])
num1 = len(cl[cl == 1])
num2 = len(cl[cl == 2])
num3 = len(cl[cl == 3])
print(np.sort([num0, num1, num2, num3]))

"""# Using DBSCAN"""

from sklearn.cluster import DBSCAN
from sklearn.model_selection import ParameterGrid

param_grid = {'eps': list(np.arange(0.05, 1, 0.05)), 'min_samples': list(range(1,10,1))}
params = list(ParameterGrid(param_grid))
sil_thr = 0  # visualize results only for combinations with silhouette above the threshold
unc_thr = 33 # visualize results only for combinations with unclustered% below the threshold

print("{:11}\t{:11}\t{:11}\t{:11}\t{:11}".\
      format('        eps','min_samples',' n_clusters',' silhouette', '    unclust%'))
for i in range(len(params)):
    db = DBSCAN(**(params[i]))
    y_db = db.fit_predict(X)
    cluster_labels_all = np.unique(y_db)
    cluster_labels = cluster_labels_all[cluster_labels_all != -1]
    n_clusters = len(cluster_labels)
    if n_clusters > 1:
        X_cl = X[y_db!=-1,:]
        y_db_cl = y_db[y_db!=-1]
        y_db_cl[-1] = y_db_cl[-2]
        silhouette = silhouette_score(X_cl,y_db_cl)
        uncl_p = (1 - y_db_cl.shape[0]/y_db.shape[0]) * 100
        if silhouette > sil_thr and uncl_p < unc_thr:
            print("{:11.2f}\t{:11}\t{:11}\t{:11.2f}\t{:11.2f}%"\
                  .format(db.eps, db.min_samples, n_clusters, silhouette, uncl_p))

# Found best parameter now using it
dbs = DBSCAN(eps=0.85, min_samples=9)
y_db = dbs.fit_predict(df)

cluster_labels_all = np.unique(y_db)
print(cluster_labels_all)
cluster_labels = cluster_labels_all[cluster_labels_all != -1]
n_clusters = len(cluster_labels)

cluster_centers = np.empty((n_clusters,X.shape[1]))
for i in cluster_labels:
    cluster_centers[i,:] = np.mean(X[y_db==i,:], axis = 0)

print(cluster_centers)
plot_clusters(X, y_db, dim=(2,1), points=cluster_centers)